[TOC]

# Lab4:死锁

### 一.产生死锁的主要原因

a）系统资源不足

b）进程运行推进的顺序不合适

c）资源分配不当

​        在系统资源充足，进程请求资源都能够的满足，死锁产生的可能性就很低，否则就会因争夺有限的资源而陷入死锁；另外，进程推进顺序与速度不同，也会产生死锁。

### 二.产生死锁的四个必要条件

a）互斥条件：一个资源每次只能被一个进程使用

b）请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放

c）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺

d）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

### 三.代码分析

​                     ![thread](https://cloud.githubusercontent.com/assets/22683831/19891209/0cecde02-a07a-11e6-999b-2fb9ddebfb9a.png)

​       上述代码创建了两个类A和B，在每个类里面都定义了两个函数，一个method函数，一个是last函数，两个函数同时使用了关键字synchronized 。

​        注意：当我们用synchronize来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。

​                    ![main](https://cloud.githubusercontent.com/assets/22683831/19891237/295c02b6-a07a-11e6-84dd-9ca270321ce2.png)

​         上述代码为主要代码，在该代码中首先声明了两个类a、b，然后在函数Deadlock中创建了一个线程t，当运行到t.start()函数之后，线程t被放到调度队列中，当调度到它的时候，就运行run里面的代码。线程t之后，当count减到0时，调用a类的methodA函数。

​                    ![bat](https://cloud.githubusercontent.com/assets/22683831/19891240/2c4ede8a-a07a-11e6-95bb-c247233007a8.png)

​         上述代码使得Deadlock函数执行1000次，并且输出执行的次数。

### 四.实验结果

​                  ![result](https://cloud.githubusercontent.com/assets/22683831/19891242/2f2b4e7c-a07a-11e6-8cdd-9d6bf29be6d6.png)

​        上述结果为Deadlock代码运行10次之时，产生了死锁。

### 五.实验结果分析

​        该实验产生死锁的原因为：在t.start()运行之后，t线程被放进了调度队列，然后当count减到0的时候就调用a类的methodA函数，进而调用b类中的last函数，最后当调度到线程t的时候就运行run函数，调用b类的methodB函数，进而调用a类中的last函数；由于上述代码要循环1000次，所以总有一次，当count减到0后，进而要调用b类中的last函数时，t线程苏醒了，即此时调度到了线程t，线程t想要运行run函数 ，在函数中要调用a类的last函数，可是此时a类中的last函数被a类函数所拥有，因此线程t被阻塞，a类的methodA函数要调用b类的last函数，可b类的last函数被线程t所拥有，由于用synchronize来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，所以此时具备了死锁产生的条件，所以产生了死锁。

### 六.实验问题

问题：刚开始代码是在虚拟机上运行的，不管怎么修改count值和循环次数，都无法产生死锁。

解决办法：最后我放弃了在虚拟机上运行，我在.bat文件里面加上输出次数，然后在windows下直接运行，结果运行10次就产生了死锁。

### 七.实验感想

​        本次实验让我再一次认识了线程和锁，同时又让我有回到了操作系统的感觉，虽然对死锁的分析是有点困难的，但是当我们分析出死锁产生的原因后，又是无比的高兴。







